{
    "terminalsCannotHaveInitializers": 
    { 
        "tip": "@Terminal decorated properties cannot have initializers, to give an initial value to a Terminal, do this in the overriden preMount() method!", 
        "videoUrl": "https://www.youtube.com/watch?v=1ZfO149BJvg&pp=ygUWdnNjb2RlIGFwaSBjb2RlYWN0aW9ucw%3D%3D" 
    },
    "childCircuitPropertiesCannotHaveInitializers": 
    { 
        "tip": "@Child decorated properties cannot have initializers, they are automatically set by Circuit-Bench!"
    },
    "cardsPropertiesCannotHaveInitializers": 
    { 
        "tip": "@Cards decorated properties cannot have initializers, they are automatically set by Circuit-Bench!"
    },
    "singletonCircuitCouldBeAddedAsChipOnceToRootCircuitOnly":
    {
        "tip": "singletonCircuitCouldBeAddedAsChipOnceToRootCircuitOnly."
    },
    "singletonCircuitAlreadyParentedWithTheRootCircuit":
    {
        "tip": "singletonCircuitCouldBeAddedAsChipOnceToRootCircuitOnly."
    },
    "onlyTypeRefAcceptedAsBaseClass":
    {
        "tip": "Only type reference is allowed to denote a base class"
    },
    "couldntRecognizeSubclassType":
    {
        "tip": "Couldn't recognize subclass type"
    },
    "registeredButDoesntExtendBaseCircuitClass":
    {
        "tip": "@Namespace decorated class must be a subclass of Circuit."
    },
    "notAllowedDecorator_class":
    {
        "tip": "This class decorator is not allowed"
    },
    "calculatorMustFollowTerminal":
    {
        "tip": "A `Calculator` method must directly follow the `Terminal` it calculates."
    },
    "notAllowedDecorator_method":
    {
        "tip": "This decorator is not allowed on a method."
    },

    "cannotMixForeignDecoratorsWithCircuitDecorators_Method":
    {
        "tip": "Cannot mix non-Circuit-Bench decorators with Circuit-Bench decorators on the same method"
    },
    "cannotMixForeignDecoratorsWithCircuitDecorators_Class":
    {
        "tip": "Cannot mix non-Circuit-Bench decorators with Circuit-Bench decorators on the same class"
    },
    "invalidDecoratorMix_Terminal_Cards":
    {
        "tip": "Cannot have both `Terminal` decorator along with `Cards` decorator on the same property."
    },
    "invalidDecoratorMix_Child_Cards":
    {
        "tip": "Cannot have both `Child` decorator along with `Cards` decorator on the same property!"
    },
    "invalidDecoratorMix_RunOn_CalcOn":
    {
        "tip": "Cannot have both `RunOn` decorator along with `CalcOn` decorator on the same method."
    },
    "calculatorReturnTypeMustLiterallyMatchItsTerminal":
    {
        "tip": "Calculator return type must literaly match the type of its preceding terminal."
    },
    "twoArgsExpected_CalcOnDecorator":
    {
        "tip": "`CalcOn` decorator expects two arguments`"
    },
    "twoArgsExpected_RunOnDecorator":
    {
        "tip": "`RunOn` decorator expects two arguments`"
    },

    "oneArgExpected_CardsDecorator":
    {
        "tip": "`Cards` decorator expects exactly one argument`"
    },
    "DEV_decoratorNodeExpectedHere":
    {
        "tip": "`DEV: A decorator node expected here!`"
    },
    "circuitTypePredicateExpected_RunOnDecorator_CircuitType":
    {
        "tip": "`A valid Circuit type predicate is expected here!"
    },
    "circuitTypePredicateExpected_CardsDecorator_CircuitType":
    {
        "tip": "`Cards` decorator expects a valid Circuit type predicate here!"
    },
    "circuitTypePredicateExpected_CalcOnDecorator_CircuitType":
    {
        "tip": "`CalcOn` decorator expects a valid Circuit type predicate here!"
    },
    "circuitTypePredicateExpected_ChildDecorator_CircuitType":
    {
        "tip": "`Child` decorator expects a valid Circuit type predicate here!"
    },
    "circuitTypePredicate_SimpleTypeRefExpected":
    {
        "tip": "A Circuit type predicate is expected to return a simple identifier resembles a reference to a Circuit Type."
    },
    "validCircuitTypeIsExpected":
    {
        "tip": "A valid Circuit type is expected!"
    },
    "terminalPredicateExpected_RunOnDecorator":
    {
        "tip": "`RunOn` decorator expects a valid `Terminal` predicate here!"
    },
    "terminalPredicateExpected_CardsDecorator":
    {
        "tip": "`Cards` decorator expects a valid `Terminal` predicate here!"
    },
    "terminalPredicateExpected_CalcOnDecorator":
    {
        "tip": "`CalcOn` decorator expects a valid `Terminal` predicate here!"
    },
    "terminalPredicateExpected_ChildDecorator":
    {
        "tip": "`Child` decorator expects a valid `Terminal` predicate here!"
    },
    "invalidTerminalPicker":
    {
        "tip": "Terminal picker predicate should look like this: x => x._SomeTerminalName"
    },
    "computedPropertyIsNotAllowedAsTerminalName":
    {
        "tip": "Computed property name are not allowed as a Terminal name!"
    },
    "onlySimpleIdentifierIsAllowedAsTerminalName":
    {
        "tip": "Only simple identifier is allowed as a Terminal name!"
    },
    "onlySimpleIdentifierIsAllowedAsCardsetName":
    {
        "tip": "Only simple identifier is allowed as a `Cards` property name!"
    },
    "circuitPickerTypeMustMatchTheDecoratedProp_Cards":
    {
        "tip": "@Cards decorated property, the return type must exactly match the decorated property type"
    },
    "circuitPickerTypeMustMatchTheDecoratedProp_Child":
    {
        "tip": "The circuit type predicate's return value of @Child decorator, must exactly match the type of the property applied for."
    },
    "typeNotWatchableInThisCircuit_CalcOn":
    {
        "tip": " This type is cannot be watched in this Circuit, since it's not self, descendant nor a singleton Circuit."
    },
    "typeNotWatchableInThisCircuit_RunOn":
    {
        "tip": "This type is cannot be watched in this Circuit, since it's not self, descendant nor a singleton Circuit."
    },
    
    "claculatorMethodCannotBeStatic":
    {
        "tip": "A `Circuit Calculator Method` cannot be static"
    },

    "childCircuitCannotBeStatic":
    {
        "tip": "A `Circuit Child Property` cannot be static"
    },
    "terminalCannotBeStatic":
    {
        "tip": "A `Circuit Terminal` cannot be static"
    },
    "terminalPropertyMustHaveExplicitTypeNotation":
    {
        "tip": "A `Circuit Terminal Property` must have an explicit type notation"
    },
    "cardsPropertyMustHaveExplicitTypeNotation":
    {
        "tip": "A `Circuit Cards Property` must have an explicit type notation"
    },
    "childPropertyMustHaveExplicitTypeNotation":
    {
        "tip": "A `Circuit Child Property` must have either an explicit type notation or a CircuitType.resolve() statement as an initializer"
    },
    "inCardsOfT_TMustExtendChildCircuit":
    {
        "tip": "A subclass of Circuit is required for the (@Childset decorated property) type."
    },
    "childTypeMustExtendChildCircuit":
    {
        "tip": "A subclass of Circuit is required for the (@Child decorated property) type."
    },
    "terminalMustHaveExplicitTypeNotation":
    {
        "tip": "@Terminal decorated property, must have an explicit type notation"
    },
    "circularCircuitComposition":
    {
        "tip": "Circuit of this type in position leads to a circular circuit composition"
    },
    "decoratorIsNotAssignableToCircuitsProperty":
    {
        "tip": "This decorator is not applicable on a Circuit's property"
    },
    "invalidPropertyDecoratorCombination":
    {
        "tip": "This decorator combination is invalid for a Circuit's property"
    },
    "invalidMethodDecoratorCombination":
    {
        "tip": "This decorator combination is invalid for a Circuit's method"
    },
    "circuitMethodsCannotBePublic":
    {
        "tip": "The access modifier of a Circuit's method can be either private or protected."
    },
    "unallowedDecoratorOnCircuitsMethod":
    {
        "tip": "This decorator is not applicable on a Circuit's method"
    },
    "handlerMemberMustFollowAnInputProperty":
    {
        "tip": "handlerMemberMustFollowAnInputProperty"
    },
    "unhandledInputBundle":
    {
        "tip": "unhandledInputBundle"
    },
    "handlerMethodMustBePrivate":
    {
        "tip": "handlerMethodMustBePrivate"
    },
    "couldntDeduceChipType":
    {
        "tip": "couldntDeduceChipType"
    },
    "noRootCircuitFound":
    {
        "tip": "No @RootCircuit() decorated class found!"
    },
    "singletonDecoratedClassMustInheritCircuit":
    {
        "tip": "singletonDecoratedClassMustInheritCircuit!"
    },
    "rootCircuitDecoratedClassMustInheritCircuit":
    {
        "tip": "rootCircuitDecoratedClassMustInheritCircuit"
    },
    "mustInheritFromCircuitToHaveThisPropertyDecorator":
    {
        "tip": "mustInheritFromCircuitToHaveThisPropertyDecorator"
    }, 
    "mustInheritFromCircuitToHaveThisMethodDecorator":
    {
        "tip": "mustInheritFromCircuitToHaveThisMethodDecorator"
    },            
    "aReceiverMustBeOfSingleTypeOfCircuit":
    {
        "tip": "aReceiverMustBeOfSingleTypeOfCircuit"
    }        
}